<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Challenge 4: Image and Registry | Azure Developer College</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/trainingdays/assets/css/0.styles.bc728db4.css" as="style"><link rel="preload" href="/trainingdays/assets/js/app.d38bf813.js" as="script"><link rel="preload" href="/trainingdays/assets/js/2.5ff1d4d5.js" as="script"><link rel="preload" href="/trainingdays/assets/js/40.a1779f5a.js" as="script"><link rel="prefetch" href="/trainingdays/assets/js/10.e0433817.js"><link rel="prefetch" href="/trainingdays/assets/js/11.cd8c7b17.js"><link rel="prefetch" href="/trainingdays/assets/js/12.12888c30.js"><link rel="prefetch" href="/trainingdays/assets/js/13.873bda65.js"><link rel="prefetch" href="/trainingdays/assets/js/14.1a24ee27.js"><link rel="prefetch" href="/trainingdays/assets/js/15.6fa51cf9.js"><link rel="prefetch" href="/trainingdays/assets/js/16.d5e02596.js"><link rel="prefetch" href="/trainingdays/assets/js/17.fcaa5f26.js"><link rel="prefetch" href="/trainingdays/assets/js/18.f2a21d28.js"><link rel="prefetch" href="/trainingdays/assets/js/19.a350c78d.js"><link rel="prefetch" href="/trainingdays/assets/js/20.bfd694b1.js"><link rel="prefetch" href="/trainingdays/assets/js/21.bed10b37.js"><link rel="prefetch" href="/trainingdays/assets/js/22.860246de.js"><link rel="prefetch" href="/trainingdays/assets/js/23.b225110a.js"><link rel="prefetch" href="/trainingdays/assets/js/24.13b22772.js"><link rel="prefetch" href="/trainingdays/assets/js/25.e0f5a7a3.js"><link rel="prefetch" href="/trainingdays/assets/js/26.c1146b2a.js"><link rel="prefetch" href="/trainingdays/assets/js/27.ab26807b.js"><link rel="prefetch" href="/trainingdays/assets/js/28.ab2698cc.js"><link rel="prefetch" href="/trainingdays/assets/js/29.496ec42d.js"><link rel="prefetch" href="/trainingdays/assets/js/3.b5657a11.js"><link rel="prefetch" href="/trainingdays/assets/js/30.fd15c623.js"><link rel="prefetch" href="/trainingdays/assets/js/31.72ed4ad1.js"><link rel="prefetch" href="/trainingdays/assets/js/32.81e15b13.js"><link rel="prefetch" href="/trainingdays/assets/js/33.f1fcf176.js"><link rel="prefetch" href="/trainingdays/assets/js/34.8432e852.js"><link rel="prefetch" href="/trainingdays/assets/js/35.61413aac.js"><link rel="prefetch" href="/trainingdays/assets/js/36.dc009a95.js"><link rel="prefetch" href="/trainingdays/assets/js/37.88c251fb.js"><link rel="prefetch" href="/trainingdays/assets/js/38.b9f64ed2.js"><link rel="prefetch" href="/trainingdays/assets/js/39.4bf7d432.js"><link rel="prefetch" href="/trainingdays/assets/js/4.316442a1.js"><link rel="prefetch" href="/trainingdays/assets/js/41.b4f159db.js"><link rel="prefetch" href="/trainingdays/assets/js/42.096f1aa1.js"><link rel="prefetch" href="/trainingdays/assets/js/43.cf13395f.js"><link rel="prefetch" href="/trainingdays/assets/js/44.92be7e22.js"><link rel="prefetch" href="/trainingdays/assets/js/45.298ad7f7.js"><link rel="prefetch" href="/trainingdays/assets/js/46.4d6179b3.js"><link rel="prefetch" href="/trainingdays/assets/js/47.bc41cef1.js"><link rel="prefetch" href="/trainingdays/assets/js/48.31275a9a.js"><link rel="prefetch" href="/trainingdays/assets/js/49.a2dc55f9.js"><link rel="prefetch" href="/trainingdays/assets/js/5.815c1276.js"><link rel="prefetch" href="/trainingdays/assets/js/50.c6016f95.js"><link rel="prefetch" href="/trainingdays/assets/js/51.0bd2785b.js"><link rel="prefetch" href="/trainingdays/assets/js/52.4e12987f.js"><link rel="prefetch" href="/trainingdays/assets/js/53.fb7850b1.js"><link rel="prefetch" href="/trainingdays/assets/js/54.1f20c333.js"><link rel="prefetch" href="/trainingdays/assets/js/55.d1950d56.js"><link rel="prefetch" href="/trainingdays/assets/js/56.3a6b8119.js"><link rel="prefetch" href="/trainingdays/assets/js/57.3639003b.js"><link rel="prefetch" href="/trainingdays/assets/js/58.091b6b2a.js"><link rel="prefetch" href="/trainingdays/assets/js/59.b1b6f798.js"><link rel="prefetch" href="/trainingdays/assets/js/6.6bc81206.js"><link rel="prefetch" href="/trainingdays/assets/js/60.8312cc43.js"><link rel="prefetch" href="/trainingdays/assets/js/61.8077d507.js"><link rel="prefetch" href="/trainingdays/assets/js/62.7099a9ec.js"><link rel="prefetch" href="/trainingdays/assets/js/63.de9324f4.js"><link rel="prefetch" href="/trainingdays/assets/js/64.69b552bd.js"><link rel="prefetch" href="/trainingdays/assets/js/65.7999d6d6.js"><link rel="prefetch" href="/trainingdays/assets/js/66.bd4052c9.js"><link rel="prefetch" href="/trainingdays/assets/js/67.e79e194c.js"><link rel="prefetch" href="/trainingdays/assets/js/68.f8d8015a.js"><link rel="prefetch" href="/trainingdays/assets/js/69.e5994ee8.js"><link rel="prefetch" href="/trainingdays/assets/js/7.60b45c24.js"><link rel="prefetch" href="/trainingdays/assets/js/70.55b1b75a.js"><link rel="prefetch" href="/trainingdays/assets/js/71.eba7950f.js"><link rel="prefetch" href="/trainingdays/assets/js/72.75c0fa4d.js"><link rel="prefetch" href="/trainingdays/assets/js/73.457d78aa.js"><link rel="prefetch" href="/trainingdays/assets/js/74.a278da89.js"><link rel="prefetch" href="/trainingdays/assets/js/75.8f7da85a.js"><link rel="prefetch" href="/trainingdays/assets/js/76.306b2367.js"><link rel="prefetch" href="/trainingdays/assets/js/77.4b93f5b5.js"><link rel="prefetch" href="/trainingdays/assets/js/78.149c6cba.js"><link rel="prefetch" href="/trainingdays/assets/js/79.df492d10.js"><link rel="prefetch" href="/trainingdays/assets/js/8.240e2339.js"><link rel="prefetch" href="/trainingdays/assets/js/80.91573785.js"><link rel="prefetch" href="/trainingdays/assets/js/9.6caa67cc.js">
    <link rel="stylesheet" href="/trainingdays/assets/css/0.styles.bc728db4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/trainingdays/" class="home-link router-link-active"><!----> <span class="site-name">Azure Developer College</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/azuredevcollege/trainingdays" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/azuredevcollege/trainingdays" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/trainingdays/" aria-current="page" class="sidebar-link">Home</a></li><li><a href="/trainingdays/day1/" class="sidebar-link">Day 1 Azure Fundamentals &amp; Infrastructure</a></li><li><a href="/trainingdays/day2/" class="sidebar-link">Day 2 Azure Development</a></li><li><a href="/trainingdays/day3/" class="sidebar-link">Day 3 Data and AI</a></li><li><a href="/trainingdays/day4/" class="sidebar-link">Day 4 Azure DevOps</a></li><li><a href="/trainingdays/day5/" class="sidebar-link">Day 5 Identity and Architecture</a></li><li><a href="/trainingdays/day6/" aria-current="page" class="sidebar-link">Day 6 Containerization</a></li><li><a href="/trainingdays/day7/" class="sidebar-link">Day 7 Kubernetes</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="challenge-4-image-and-registry"><a href="#challenge-4-image-and-registry" class="header-anchor">#</a> Challenge 4: Image and Registry</h1> <h2 id="here-is-what-you-ll-learn"><a href="#here-is-what-you-ll-learn" class="header-anchor">#</a> Here is what you'll learn</h2> <ul><li>Tagging</li> <li>Image pull and push</li> <li>Building your own image</li> <li>Image registries and repositories</li></ul> <p>In this challenge, we're gonna play with Docker Images. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.</p> <h2 id="exercises"><a href="#exercises" class="header-anchor">#</a> Exercises</h2> <p><strong>1: Tagging</strong></p><details><summary>Click to expand!</summary><p></p> <p>Let's pull an image. The command that we use is <code>docker pull</code>. With that command, we're requesting from Docker that we want to download an image from its registry to the host.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker pull ubuntu:latest
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>latest: Pulling from library/ubuntu
3ff22d22a855: Pull complete
e7cb79d19722: Pull complete
323d0d660b6a: Pull complete
b7f616834fd0: Pull complete
Digest: sha256:5d1d5407f353843ecf8b16524bc5565aa332e9e6a1297c73a92d3e754b8a636d
Status: Downloaded newer image <span class="token keyword">for</span> ubuntu:latest
docker.io/library/ubuntu:latest
</code></pre></div><p>Now it's time to see which images that we have on our system. For this, we're gonna type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image <span class="token function">ls</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              latest              1e4467b07108        <span class="token number">2</span> weeks ago         <span class="token number">73</span>.9MB
</code></pre></div><p>I want you to pay attention to the image id part. Like containers, images also have unique ids. The image ID is a digest, and is a computed SHA256 hash of the image configuration object, which contains the digests of the layers that contribute to the image's filesystem definition. If two different images have the same ids, this means that they're literally same images with different names.
Yes it's possible to tag an image with different tags. Let's do that and add another name to this image.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image tag ubuntu:latest your_dockerhub_id/day6:ubuntu
</code></pre></div><p>We have added a second name to the image. Let's check and see.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image <span class="token function">ls</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
ubuntu                latest              1e4467b07108        <span class="token number">2</span> weeks ago         <span class="token number">73</span>.9MB
ozgurozturknet/day6   ubuntu              1e4467b07108        <span class="token number">2</span> weeks ago         <span class="token number">73</span>.9MB
</code></pre></div><p>We have 2 images that are stored on our host. Image ids are same, so these are literally the same images but with different names.</p> <p>We have added a new tag-name to ubuntu:latest image. We tagged it with our Docker Hub id. This means that this image is stored &quot;or will be stored&quot; on Docker Hub (Remember, image names are also indicates where image is located). But it isn't at the moment. Let's correct this and push this image to its repository. But before that we have to login and authenticate. In this way, Docker Hub knows that we're the right person who can push this image to its respository. Let's login first.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker login
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, <span class="token function">head</span> over to https://hub.docker.com to create one.
Username: ozgurozturknet
Password:
Login Succeeded
</code></pre></div><p>Now we're ready to push.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker push your_dockerhub_id/day6:ubuntu
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>The push refers to repository <span class="token punctuation">[</span>docker.io/ozgurozturknet/day6<span class="token punctuation">]</span>
095624243293: Mounted from library/ubuntu
a37e74863e72: Mounted from library/ubuntu
8eeb4a14bcb4: Mounted from library/ubuntu
ce3011290956: Mounted from library/ubuntu
ubuntu: digest: sha256:60f560e52264ed1cb7829a0d59b1ee7740d7580e0eb293aca2d722136edb1e24 size: 11529MB
</code></pre></div><p>It was fast, wasn't it? Please pay attention to the output. <code>Mounted from library/ubuntu</code>. You know that images consist of multiple layers. And each layer has its unique id. When we pull or push any image, if the target (registry or your computer) has the same layer with same id stored on it, it doesn't pull or push that layer phyiscally again. Just checks and mounts that. This is the reason why it was fast. We didn't transfer any file to Docker Hub. Docker Hub detected that these 4 layers are already stored on it, so instead of getting it again, Docker hub just mounted these files to our repository. This is also same on our computer. We have 2 images stored on it. But they are literally the same images with different names. Docker doesn't store multiple files for these 2 images. Image files are stored just once but multiple tags added to the same files.</p> <p>But what are these layers? Is there any way to see how are they created? Yes and the command that we'll use is <code>docker image history</code>. History sub-command shows us history of the image and it also shows how all these layers were created. Let's check this.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image <span class="token function">history</span> ubuntu:latest
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>1e4467b07108        <span class="token number">2</span> weeks ago         /bin/sh -c <span class="token comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">2</span> weeks ago         /bin/sh -c <span class="token function">mkdir</span> -p /run/systemd <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">'do…   7B
&lt;missing&gt;           2 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo '</span><span class="token comment">#!/bin/sh' &gt; /…   811B</span>
<span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">2</span> weeks ago         /bin/sh -c <span class="token punctuation">[</span> -z <span class="token string">&quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">apt-get</span> indextargets<span class="token variable">)</span></span>&quot;</span> <span class="token punctuation">]</span>     <span class="token number">1</span>.01MB
<span class="token operator">&lt;</span>missing<span class="token operator">&gt;</span>           <span class="token number">2</span> weeks ago         /bin/sh -c <span class="token comment">#(nop) ADD file:65a1cc50a9867c153…   72.9MB</span>
</code></pre></div><p>This output shows us which commands have been executed and which layers have been created as a result of these commands. This also gives us some clues about how an image is created.</p> <p>Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using <code>docker build</code>, users can create an automated build that executes several command-line instructions in succession. Each instruction that changes anything creates a new layer. The Docker daemon runs the instructions in the Dockerfile one-by-one, committing the result of each instruction to a new image if necessary, before finally outputting the ID of your new image. It's now time to create our first image.
</p></details><p></p> <hr> <p><strong>2: Building the first image</strong></p><details><summary>Click to expand!</summary><p></p> <p>First, we should clone this Github repository.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token function">git</span> clone https://github.com/azuredevcollege/trainingdays.git
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Cloning into <span class="token string">'trainingdays'</span><span class="token punctuation">..</span>.
remote: Enumerating objects: <span class="token number">42</span>, done.
remote: Counting objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">42</span>/42<span class="token punctuation">)</span>, done.
remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">31</span>/31<span class="token punctuation">)</span>, done.
remote: Total <span class="token number">1899</span> <span class="token punctuation">(</span>delta <span class="token number">26</span><span class="token punctuation">)</span>, reused <span class="token number">25</span> <span class="token punctuation">(</span>delta <span class="token number">11</span><span class="token punctuation">)</span>, pack-reused <span class="token number">1857</span> Receiving objects:  <span class="token number">97</span>% <span class="token punctuation">(</span><span class="token number">1843</span>/1899<span class="token punctuation">)</span>, <span class="token number">57.20</span> MiB <span class="token operator">|</span> <span class="token number">11.92</span> MiB/s
Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1899</span>/1899<span class="token punctuation">)</span>, <span class="token number">63.35</span> MiB <span class="token operator">|</span> <span class="token number">11.26</span> MiB/s, done.
Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">747</span>/747<span class="token punctuation">)</span>, done.
Updating files: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1396</span>/1396<span class="token punctuation">)</span>, done.
</code></pre></div><p>Repo has been cloned. It's time to jump to the
<code>trainingdays/day6/apps/first_docker_image</code> folder. cd to that folder and
list all the files.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token builtin class-name">cd</span> trainingdays/day6/apps/first_docker_image
$ <span class="token function">ls</span> -l
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">8</span>
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk  <span class="token number">90</span> Jun <span class="token number">12</span> <span class="token number">11</span>:56 Dockerfile
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk <span class="token number">211</span> Jun <span class="token number">12</span> <span class="token number">11</span>:21 index.html
</code></pre></div><p>There are 2 files in that folder. <code>index.html</code> is a simple html file that has been created by us. We want to build a web server image with this file has been copied in it. To be able to build an image, we need a <code>Dockerfile</code>. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. We have one in this folder. Let's check and see what's in it. This is one of the simplest form of a Dockerfile.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token function">cat</span> Dockerfile
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>FROM nginx:latest
COPY index.html /usr/share/nginx/html
CMD <span class="token punctuation">[</span><span class="token string">&quot;nginx&quot;</span>, <span class="token string">&quot;-g&quot;</span>, <span class="token string">&quot;daemon off;&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>If we cd to a folder which has Dockerfile in it and type <code>docker image build .</code>, Docker starts to run instructions in that Dockerfile in order. A Dockerfile must begin with the &quot;FROM&quot; instruction. &quot;FROM&quot; instruction specifies the Parent Image that you are trying to build this new image on top of. <code>FROM</code> basically means that &quot;hey Docker, download that image and execute the next instructions on top of that&quot;. It's the base image that we build our image on top of. In our case, it is <code>nginx:latest</code>. We're building our image on top of ngninx:latest.</p> <p>The second instruction in that Dockerfile is <code>COPY</code>. The COPY instruction copies new files or directories from &quot;source&quot; to the &quot;destination&quot; inside the container. In our case, we have instructed Docker to copy the <code>index.html</code> file located in the current folder to the <code>/usr/share/nginx/html</code> folder inside the image. <code>/usr/share/nginx/html</code> is the folder where Nginx stores websites that it serves. We copied our index.html to that folder, So nginx daemon will serve our web page.</p> <p>The third and last instruction in this Dockerfile is CMD. The main purpose of the &quot;CMD&quot; instruction is that providing defaults of an executing container. In short, it defines the command to execute when you run a container from that image. There can be only one CMD instruction in any Dockerfile. If you list more than one CMD then only the last CMD will take effect. In our case, we want Docker to start nginx daemon when we create a container.</p> <p>Ok, it's time to create our first image. We checked the Dockerfile and see what it includes. Now we can build the first image.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image build -t your_dockerhub_id/firstimage:latest <span class="token builtin class-name">.</span> <span class="token comment">#do not forget the dot</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">3</span>.072kB
Step <span class="token number">1</span>/3 <span class="token builtin class-name">:</span> FROM nginx:latest
 ---<span class="token operator">&gt;</span> 08393e824c32
Step <span class="token number">2</span>/3 <span class="token builtin class-name">:</span> COPY index.html /usr/share/nginx/html
 ---<span class="token operator">&gt;</span> 14fb48dc6eea
Step <span class="token number">3</span>/3 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span><span class="token string">&quot;nginx&quot;</span>, <span class="token string">&quot;-g&quot;</span>, <span class="token string">&quot;daemon off;&quot;</span><span class="token punctuation">]</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 772fbfd4dba3
Removing intermediate container 772fbfd4dba3
 ---<span class="token operator">&gt;</span> 560570bf44e5
Successfully built 560570bf44e5
Successfully tagged ozgurozturknet/firstimage:latest
</code></pre></div><p>Congrats! We have built our first image. Let's create a container to see if it's working as expect.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run --rm -d -p <span class="token number">80</span>:80 --name test_container your_dockerhub_id/firstimage:latest
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>25e7fe3f3e57dd2eab07bf672501dde69d81eb156347607e0b378757b41d859b
</code></pre></div><p>Open a browser and visit http://127.0.0.1 You would see a page like that.</p> <img src="/trainingdays/assets/img/firstimage.329e6e43.png"> <p>Stop the container and it'll be deleted automatically.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container stop test_container
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>test_container
</code></pre></div></details> <hr> <p><strong>3: Building a node.js image</strong></p><details><summary>Click to expand!</summary><p></p> <p>This time we're gonna build a node.js app image. cd to the <code>/trainingdays/day6/apps/nodejs</code> folder and list all the files.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token builtin class-name">cd</span> /trainingdays/day6/apps/nodejs
$ <span class="token function">ls</span> -l
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">12</span>
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk <span class="token number">292</span> Aug <span class="token number">12</span> <span class="token number">20</span>:27 Dockerfile
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk <span class="token number">288</span> Aug <span class="token number">12</span> <span class="token number">20</span>:14 package.json
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk <span class="token number">273</span> Aug <span class="token number">12</span> <span class="token number">20</span>:15 server.js
</code></pre></div><p>This time we have 3 files. First one is <code>package.json</code>. If you work with JavaScript, or you've ever interacted with a JavaScript project, Node.js or a frontend project, you surely met the package.json file. The package.json file is kind of a manifest for your project. It can do a lot of things, but in our case it's specially important because it defines the dependencies that we'll install with npm. Our simple node application is running on top of Express framework and we need that framework to be installed to run our simple Javascript webapp. <code>Server.js</code> is the second file and it's our main Javascript application. It's a simple &quot;Hello World&quot; web app. And the third one is the usual suspect. Dockerfile. Let's take a look at it.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token function">cat</span> Dockerfile
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># source: https://nodejs.org/en/docs/guides/nodejs-docker-webapp/</span>
FROM node:12

<span class="token comment"># Create app directory</span>
WORKDIR /usr/src/app

<span class="token comment"># Copy source files</span>
COPY package.json <span class="token builtin class-name">.</span>
COPY server.js <span class="token builtin class-name">.</span>

<span class="token comment"># Install app dependencies</span>
RUN <span class="token function">npm</span> <span class="token function">install</span>

<span class="token comment"># Exposing the port 8080</span>
EXPOSE <span class="token number">8080</span>

CMD <span class="token punctuation">[</span> <span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;server.js&quot;</span> <span class="token punctuation">]</span>
</code></pre></div><p>I want you to pay attention to 2 things. First, as you can see, we can add comments to Dockerfile. Any line starting with <code>#</code> is treated as a comment and not processed. Second, we have 3 new instructions, <code>WORKDIR</code> , <code>RUN</code> and <code>EXPOSE</code>. The default working directory for running binaries within a container is the root directory (/), but you can set a different folder by using &quot;WORKDIR&quot; instruction. It's kind of cd'ing to that folder. Any command that you execute after that insturction will be executed in this folder. If there isn't any folder with that name in the image, Docker creates the folder first but If there is, Docker uses that.</p> <p>The &quot;RUN&quot; instruction will execute any commands in a new layer on top of the current image and commit the results. The resulting committed image will be used for the next step in the Dockerfile. When we want to execute anything, we use this instruction.</p> <p>The &quot;EXPOSE&quot; instruction informs Docker that the container listens on the specified network ports at runtime. You can specify whether the port listens on TCP or UDP, and the default is TCP if the protocol is not specified. The EXPOSE instruction does not actually publish the port. It functions as a type of documentation about which ports are intended to be published between the person who builds the image and the person who runs the container. To actually publish any port, we should use the -p flag during container creation.</p> <p>Now it's time to build the image.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image build -t your_dockerhub_id/node:latest <span class="token builtin class-name">.</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">4</span>.096kB
Step <span class="token number">1</span>/7 <span class="token builtin class-name">:</span> FROM node:12
 ---<span class="token operator">&gt;</span> cfcf3e70099d
Step <span class="token number">2</span>/7 <span class="token builtin class-name">:</span> WORKDIR /usr/src/app
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 0784285bb528
Removing intermediate container 0784285bb528
 ---<span class="token operator">&gt;</span> 548e712ed3ef
Step <span class="token number">3</span>/7 <span class="token builtin class-name">:</span> COPY package.json <span class="token builtin class-name">.</span>
 ---<span class="token operator">&gt;</span> 3f85bf98e435
Step <span class="token number">4</span>/7 <span class="token builtin class-name">:</span> COPY server.js <span class="token builtin class-name">.</span>
 ---<span class="token operator">&gt;</span> beb25f72bb6a
Step <span class="token number">5</span>/7 <span class="token builtin class-name">:</span> RUN <span class="token function">npm</span> <span class="token function">install</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> e3eed8b0c46d
<span class="token function">npm</span> notice created a lockfile as package-lock.json. You should commit this file.
<span class="token function">npm</span> WARN docker_web_app@1.0.0 No repository field.
<span class="token function">npm</span> WARN docker_web_app@1.0.0 No license field.

added <span class="token number">50</span> packages from <span class="token number">37</span> contributors and audited <span class="token number">50</span> packages <span class="token keyword">in</span> <span class="token number">2</span>.167s
found <span class="token number">0</span> vulnerabilities

Removing intermediate container e3eed8b0c46d
 ---<span class="token operator">&gt;</span> 8d3082c10a9e
Step <span class="token number">6</span>/7 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">8080</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 0e6bd014ac73
Removing intermediate container 0e6bd014ac73
 ---<span class="token operator">&gt;</span> 5143985531f3
Step <span class="token number">7</span>/7 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span> <span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;server.js&quot;</span> <span class="token punctuation">]</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 152317b9eafe
Removing intermediate container 152317b9eafe
 ---<span class="token operator">&gt;</span> a832145edf14
Successfully built a832145edf14
Successfully tagged ozgurozturknet/node:latest
</code></pre></div><p>Image has been built successfully. But I want you to run the same command one more time.</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">4</span>.096kB
Step <span class="token number">1</span>/7 <span class="token builtin class-name">:</span> FROM node:12
 ---<span class="token operator">&gt;</span> cfcf3e70099d
Step <span class="token number">2</span>/7 <span class="token builtin class-name">:</span> WORKDIR /usr/src/app
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 3d04799d4f2a
Step <span class="token number">3</span>/7 <span class="token builtin class-name">:</span> COPY package.json <span class="token builtin class-name">.</span>
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> a348cb47ad20
Step <span class="token number">4</span>/7 <span class="token builtin class-name">:</span> COPY server.js <span class="token builtin class-name">.</span>
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 5affbe5fce86
Step <span class="token number">5</span>/7 <span class="token builtin class-name">:</span> RUN <span class="token function">npm</span> <span class="token function">install</span>
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> ad11b36a3604
Step <span class="token number">6</span>/7 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">8080</span>
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 57b485f4eef1
Step <span class="token number">7</span>/7 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span> <span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;server.js&quot;</span> <span class="token punctuation">]</span>
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> fb0586534394
Successfully built fb0586534394
Successfully tagged ozgurozturknet/node:latest
</code></pre></div><p>Something strange has happened. We built that image a few seconds ago and we didn't change any source file after that. Then we reran the docker image build command second time but we received lots of <code>---&gt; Using cache</code> messages this time. What does that mean?</p> <p>When building an image, Docker steps through the instructions in your Dockerfile, executing each in the order specified. As each instruction is examined, Docker looks for an existing layers in its cache that it can reuse, rather than creating a new (duplicate) layer. If you don't change any source file or didn't change anything in the Dockerfile, this means that nothing has changed, so Docker doesn't run the instruction again and again. Instead of that, Docker uses the cached layers. That makes the build process fast. Let's simulate that and see what happens if we change something. Open <code>server.js</code> file with a text editor, go to line 12 and change the <code>Hello World</code> message with another message something like <code>build cache test</code>. Save the file and rerun <code>docker image build -t your_dockerhub_id/node:latest .</code> command one more time.</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">4</span>.096kB
Step <span class="token number">1</span>/7 <span class="token builtin class-name">:</span> FROM node:12
 ---<span class="token operator">&gt;</span> cfcf3e70099d
Step <span class="token number">2</span>/7 <span class="token builtin class-name">:</span> WORKDIR /usr/src/app
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> 3d04799d4f2a
Step <span class="token number">3</span>/7 <span class="token builtin class-name">:</span> COPY package.json <span class="token builtin class-name">.</span>
 ---<span class="token operator">&gt;</span> Using cache
 ---<span class="token operator">&gt;</span> a348cb47ad20
Step <span class="token number">4</span>/7 <span class="token builtin class-name">:</span> COPY server.js <span class="token builtin class-name">.</span>
 ---<span class="token operator">&gt;</span> 800aa5cd76d2
Step <span class="token number">5</span>/7 <span class="token builtin class-name">:</span> RUN <span class="token function">npm</span> <span class="token function">install</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 20f6c9a2c4e0
<span class="token function">npm</span> notice created a lockfile as package-lock.json. You should commit this file.
<span class="token function">npm</span> WARN docker_web_app@1.0.0 No repository field.
<span class="token function">npm</span> WARN docker_web_app@1.0.0 No license field.

added <span class="token number">50</span> packages from <span class="token number">37</span> contributors and audited <span class="token number">50</span> packages <span class="token keyword">in</span> <span class="token number">2</span>.521s
found <span class="token number">0</span> vulnerabilities

Removing intermediate container 20f6c9a2c4e0
 ---<span class="token operator">&gt;</span> eac206f9957e
Step <span class="token number">6</span>/7 <span class="token builtin class-name">:</span> EXPOSE <span class="token number">8080</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 3084d34a448f
Removing intermediate container 3084d34a448f
 ---<span class="token operator">&gt;</span> 1e4c0a700aa6
Step <span class="token number">7</span>/7 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span> <span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;server.js&quot;</span> <span class="token punctuation">]</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> b0fae2027731
Removing intermediate container b0fae2027731
 ---<span class="token operator">&gt;</span> 729b13c3276f
Successfully built 729b13c3276f
Successfully tagged ozgurozturknet/node:latest
</code></pre></div><p>Docker started to build an image again. First step, nothing changed, used the cache. Second step, nothing changed, used the cache. Third step, nothing changed, used the cache. But fourth step, we wanted to copy server.js file, which has been changed. Old layer that Docker has created and cached before is invalid now. So Docker started to execute that instruction and created a new layer and didn't use the cached version. And each instruction after that has been executed again and Docker didn't use the cache. Because something has changed and the rest of the layers should be affected too. Therefore, Docker can't use cache for them too. That's kind of important thing to know. Because you can speed up build process by leveraging build cache. But order of Dockerfile instructions is important.</p> <p>For example, if your Dockerfile contains several instruction, like ours, you can order them from the less frequently changed (to ensure the build cache is reusable) to the more frequently changed. If we move  <code>COPY server.js .</code> from 4. step to anywhere after the <code>RUN npm install</code> instruction, this means that, we can change anything in this server.js file and Docker will not rerun npm install each time when we build that image again and use cache for that step.
(Visit https://docs.docker.com/develop/develop-images/dockerfile_best-practices/  for Dockerfile best practices)</p> <p>It's time to create a container from that image and see if it's working properly.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run --rm -d -p <span class="token number">80</span>:8080 --name node_container your_dockerhub_id/node:latest
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>09a4d1789cdab19a0f3af9c66a4f6e68503e5b8a1f46d6c512e88b10c5e70011
</code></pre></div><p>Open a browser and visit http://127.0.0.1 You would see a page with a Hello World! message.</p> <p>Stop the container and it'll be deleted automatically.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container stop node_container
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>node_container
</code></pre></div></details> <hr> <p><strong>4: Multi-stage build</strong></p><details><summary>Click to expand!</summary><p></p> <p>Let's imagine that we're java developers and working on a new shiny project called App1 (Do you remember our old friend 😃). Application has been written and it's ready. Now it is time to check the source code. It's located at <code>/trainingdays/day6/apps/java</code> folder. cd to that folder and list all the files.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token builtin class-name">cd</span> /trainingdays/day6/apps/java
$ <span class="token function">ls</span> -l
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">8</span>
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk <span class="token number">135</span> Jun <span class="token number">12</span> <span class="token number">22</span>:43 Dockerfile
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk <span class="token number">154</span> Jun <span class="token number">12</span> <span class="token number">22</span>:35 app1.java
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk <span class="token number">154</span> Jun <span class="token number">12</span> <span class="token number">22</span>:35 Dockerfile2
</code></pre></div><p>There are 2 files in it (actually 3 but let's forget Dockerfile2 for now). <code>app1.java</code> is the source code of our application. Please pay attention. It is not the application, it is just the source code of this application. It isn't compiled yet. To convert this source code to an application, we have to compile this code. We generally do that on our computers via IDEs. But we can use the power of Docker and compile our application while building the image. The Dockerfile in this folder is a good example of that practice. Let's check the Dockerfile.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token function">cat</span> Dockerfile
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>FROM mcr.microsoft.com/java/jdk:8-zulu-alpine
COPY <span class="token builtin class-name">.</span> /usr/src/myapp/
WORKDIR /usr/src/myapp
RUN javac app1.java
CMD <span class="token punctuation">[</span> <span class="token string">&quot;java&quot;</span> , <span class="token string">&quot;app1&quot;</span> <span class="token punctuation">]</span>
</code></pre></div><p>Again, a simple Dockerfile. We want to build our image on top of the &quot;Java Development Kit&quot; image provided by Microsoft. JDK image has all the tools in it that we need to compile our java code and convert it to a java application. First, we copy that source code to the image and after that we jump into that folder and run <code>javac app1.java</code> command which compiles this source code and generates an application. At the end, we have a CMD instruction that instructs to run this application whenever we create a container from that image. Let's build the image.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image build -t your_dockerhub_id/java:latest <span class="token builtin class-name">.</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">3</span>.072kB
Step <span class="token number">1</span>/5 <span class="token builtin class-name">:</span> FROM mcr.microsoft.com/java/jdk:8-zulu-alpine
<span class="token number">8</span>-zulu-alpine: Pulling from java/jdk
df20fa9351a1: Pull complete
1e7717fd7ab1: Pull complete
Digest: sha256:19712872c6dd8ca02a8f727737372477559f2659aa6294c2dcae050096234224
Status: Downloaded newer image <span class="token keyword">for</span> mcr.microsoft.com/java/jdk:8-zulu-alpine
 ---<span class="token operator">&gt;</span> b7bb6dd0ee76
Step <span class="token number">2</span>/5 <span class="token builtin class-name">:</span> COPY <span class="token builtin class-name">.</span> /usr/src/myapp/
 ---<span class="token operator">&gt;</span> ed2f0977e390
Step <span class="token number">3</span>/5 <span class="token builtin class-name">:</span> WORKDIR /usr/src/myapp
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> d2333b9e9af3
Removing intermediate container d2333b9e9af3
 ---<span class="token operator">&gt;</span> 55a151ddf81a
Step <span class="token number">4</span>/5 <span class="token builtin class-name">:</span> RUN javac app1.java
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> b8697de33caa
Removing intermediate container b8697de33caa
 ---<span class="token operator">&gt;</span> 3bfd240a44ff
Step <span class="token number">5</span>/5 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span> <span class="token string">&quot;java&quot;</span> , <span class="token string">&quot;app1&quot;</span> <span class="token punctuation">]</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 00a6a2a448ab
Removing intermediate container 00a6a2a448ab
 ---<span class="token operator">&gt;</span> ceab35948e29
Successfully built ceab35948e29
Successfully tagged ozgurozturknet/java:latest
</code></pre></div><p>Image has been built. Let's test it.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run your_dockerhub_id/java:latest
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Hello there<span class="token operator">!</span> I'm App1 Java Console Application
</code></pre></div><p>Perfect. It works. App1 has been compiled and it runs. But it seems to me that, something is wrong with that approach. First of all, we built our image on top of the JDK image. It includes lots of tools for development. Like the one that we ran to compile our application. But, should we really send this image to our customers as is? With all of these development tools? Also our source code is copied to that image too. Maybe that is not something we want. We just wanted to compile our source code and get the application. We want our customers to be able to run this application. We don't want them to have all the unnecessary tools and our source code. Also image size is big, because of these unnecessary tools. These tools are needed for development. They are not needed for running java applications. JRE, java runtime is the thing that we need to run java applications. It's just the runtime and much smaller than the jdk.</p> <p>Instead of sending this image, It would be wise to get this compiled application from that image, copy it to our computer and create another image that includes just this application + runtime, instead of application + source code + development tools. So we need to build another image. To be able to do that, we need to create a second Dockerfile. But eeeh. This is a mess. There should be a simple solution.
Yes there is a simple solution to handle this and it's called multi-stage build.</p> <p>One of the most challenging thing about building images is keeping the image size down. Each instruction in Dockerfile adds a layer to image, and you need to remember to clean up any artifacts you don’t need before moving on to the next layer. To write a really efficient Dockerfile, you have traditionally needed to employ shell tricks and other logic to keep the layers as small as possible and to ensure that each layer has the artifacts it needs from the previous layer and nothing else. It was actually very common to have one Dockerfile to use for development (which contained everything needed to build your application), and a slimmed-down one to use for production, which only contained your application and exactly what was needed to run it. This has been referred to as the “builder pattern”. But maintaining two Dockerfiles is not ideal.</p> <p>With multi-stage builds, you can use multiple FROM statements in your Dockerfile. Each FROM instruction can use a different base, and each of them begins a new stage of the build. You can selectively copy artifacts from one stage to another, leaving behind everything you don’t want in the final image. Dockerfile2 is a perfect example of this kind of multi-stage build. Let's check it.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token function">cat</span> Dockerfile2
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>FROM mcr.microsoft.com/java/jdk:8-zulu-alpine AS builder
COPY <span class="token builtin class-name">.</span> /usr/src/myapp/
WORKDIR /usr/src/myapp
RUN javac app1.java

FROM  mcr.microsoft.com/java/jre:8-zulu-alpine
WORKDIR /usr/src/myapp
COPY --from<span class="token operator">=</span>builder /usr/src/myapp <span class="token builtin class-name">.</span>
CMD <span class="token punctuation">[</span><span class="token string">&quot;java&quot;</span>, <span class="token string">&quot;app1&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>As you can see, we have a Dockerfile with 2 &quot;FROM&quot; instructions. Think it like 2 Dockerfiles combined together. First part is similar to the Dockerfile that we have built our application a few minutes ago. There are only 2 differences. First, there is a new section at the end of the &quot;FROM&quot; instruction. &quot;AS builder&quot; or it could be &quot;AS anything&quot;, just name it. It indicates that this first section of this Dockerfile is named as &quot;builder&quot;. We're gonna use this name later to copy artifacts generated in this stage. Second difference is that &quot;CMD&quot; instruction has been removed, because we don't need it anymore. This &quot;builder&quot; stage is just used for compiling the application from its source code. We're taking our source code, copying it into a jdk image, compiling the application in it and that's it. After that we are building our actual image with a new &quot;FROM&quot; instruction. This second stage will create the actual image that will be tagged at the end. It's based on JRE image, not the JDK.</p> <p>Please pay attention to line 8. &quot;COPY --from=builder&quot;. We're instructing Docker to copy files from stage called builder. First stage is there just to compile our application. Our source code has been compiled and application has been created at this builder stage. And we're copying just this compiled application into final image. In this way, jdk and any intermediate artifacts are left behind and not present in the final image. The end result is this tiny production image that just includes the application. Not the source code and not the development tools. Let's build this image and see what's going on.
(We're gonna use <code>-f</code> option to point this Dockerfile2. If your Dockerfile name is different than Dockerfile -First letter is Uppercase &quot;D&quot; and file doesn't have any extension like .txt- or Dockerfile is in another folder, you should use -f option and point that file)</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image build -f Dockerfile2 -t your_dockerhub_id/finaljava:latest <span class="token builtin class-name">.</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">4</span>.096kB
Step <span class="token number">1</span>/8 <span class="token builtin class-name">:</span> FROM mcr.microsoft.com/java/jdk:8-zulu-alpine AS builder
 ---<span class="token operator">&gt;</span> b7bb6dd0ee76
Step <span class="token number">2</span>/8 <span class="token builtin class-name">:</span> COPY <span class="token builtin class-name">.</span> /usr/src/myapp/
 ---<span class="token operator">&gt;</span> 786a33a37acb
Step <span class="token number">3</span>/8 <span class="token builtin class-name">:</span> WORKDIR /usr/src/myapp
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 1145e3882420
Removing intermediate container 1145e3882420
 ---<span class="token operator">&gt;</span> 5f16de8216fb
Step <span class="token number">4</span>/8 <span class="token builtin class-name">:</span> RUN javac app1.java
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 98375300d10a
Removing intermediate container 98375300d10a
 ---<span class="token operator">&gt;</span> f632a0c6f49e
Step <span class="token number">5</span>/8 <span class="token builtin class-name">:</span> FROM  mcr.microsoft.com/java/jre:8-zulu-alpine
<span class="token number">8</span>-zulu-alpine: Pulling from java/jre
df20fa9351a1: Already exists
b391ad10af71: Pull complete
Digest: sha256:bb7135444a7e78448b0038d26079e6bef78c1c7839333bf9806d6c12e65a1eff
Status: Downloaded newer image <span class="token keyword">for</span> mcr.microsoft.com/java/jre:8-zulu-alpine
 ---<span class="token operator">&gt;</span> 36c60fc08a2d
Step <span class="token number">6</span>/8 <span class="token builtin class-name">:</span> WORKDIR /usr/src/myapp
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 25809e0fd983
Removing intermediate container 25809e0fd983
 ---<span class="token operator">&gt;</span> 5b580490d819
Step <span class="token number">7</span>/8 <span class="token builtin class-name">:</span> COPY --from<span class="token operator">=</span>builder /usr/src/myapp <span class="token builtin class-name">.</span>
 ---<span class="token operator">&gt;</span> e357def56d05
Step <span class="token number">8</span>/8 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span><span class="token string">&quot;java&quot;</span>, <span class="token string">&quot;app1&quot;</span><span class="token punctuation">]</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 00585394dbfb
Removing intermediate container 00585394dbfb
 ---<span class="token operator">&gt;</span> 7b7c6b3a7f6a
Successfully built 7b7c6b3a7f6a
Successfully tagged ozgurozturknet/finaljava:latest
</code></pre></div><p>Final image has been built. It's much smaller than the first one. Also only artifacts that we need are included.
</p></details><p></p> <hr> <p><strong>5: Php contacts app</strong></p><details><summary>Click to expand!</summary><p></p> <p>This time, we're gonna combine what have we learned so far. We will build 2 images. First one is a simple php application. The other one is famous mysql database. After building images, we will run these and try couple of tricks that we have learned so far. First, let's check and see what we're gonna build. All files are located at <code>/trainingdays/day6/apps/php</code> folder. cd to that folder and list all the files.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token builtin class-name">cd</span> /trainingdays/day6/apps/php
$ <span class="token function">ls</span> -l
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>total <span class="token number">24</span>
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk  <span class="token number">333</span> Aug <span class="token number">13</span> <span class="token number">11</span>:54 Dockerfile
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk   <span class="token number">64</span> Aug <span class="token number">13</span> <span class="token number">11</span>:36 Dockerfile.mysql
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk  <span class="token number">112</span> Aug <span class="token number">13</span> <span class="token number">11</span>:36 createtable.sql
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk   <span class="token number">81</span> Aug <span class="token number">13</span> <span class="token number">11</span>:36 env.list
-rw-r--r-- <span class="token number">1</span> ozozturk ozozturk  <span class="token number">107</span> Aug <span class="token number">13</span> <span class="token number">11</span>:36 envmysql.list
drwxr-xr-x <span class="token number">2</span> ozozturk ozozturk <span class="token number">4096</span> Aug <span class="token number">13</span> <span class="token number">11</span>:35 php
</code></pre></div><p>It's a little bit crowded folder. There are 2 Dockerfiles. First one is the Dockerfile that we'll be used to build web app image. Second one will be used to build myqsql database image.</p> <p>There are 2 other files with .list extenison in this folder. These files will be used to define environment variables while creating containers. &quot;env.list&quot; will be passed to php web container. There are couple of environment variables defined in this file and php web application will use these values to connect to the database -username, password etc.-. &quot;envmysql.list&quot; is another environment  variable file and has couple of other environment  variables defined in it. We'll pass this values to mysql container. mysql container will start and create a database using these parameters. Essentially, we could inject these variables into the Dockerfiles. Yes, it's possible. We can define environment variables with <code>ENV</code> instruction in any Dockerfile and any container created from that image will have these environment variables. But if we do that, these will be hardcoded to image. This means that whoever get this image can access to these values. Especially this isn't a thing that we want for sensitive data like passwords. Therefore, we didn't define them in Dockerfiles. Instead of that, we will pass these values during container creation.</p> <p>&quot;createtable.sql&quot; is an sql script that will create a table, which will be used by php web app to store its data. We'll copy this script to a special folder in the image. When we create a container from that image, mysql will create a table using that script.</p> <p>&quot;php&quot; is the folder where our main web app is located. There are 3 files in that folder. It's really a simple web app which allows us to record contact details. Kind of primitive crm.</p> <p>Let's have a look at Dockerfiles before building images.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token function">cat</span> Dockerfile
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>FROM php:7.3-apache
RUN <span class="token function">apt-get</span> update -y <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">curl</span> mariadb-client-10.3 -y
RUN docker-php-ext-install mysqli <span class="token operator">&amp;&amp;</span> docker-php-ext-enable mysqli
RUN <span class="token function">mkdir</span> /var/www/html/images
RUN <span class="token function">chmod</span> <span class="token number">777</span> /var/www/html/images
COPY ./php/ /var/www/html/
HEALTHCHECK --interval<span class="token operator">=</span>30s --timeout<span class="token operator">=</span>3s CMD <span class="token function">curl</span> -f http://localhost/ <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
</code></pre></div><p>We use official php image as our base. Then we install couple of binaries that we need and create a folder where we'll store uploaded images. After that we copy our web app into image. So far nothing unknown. But now we have a new instruction, &quot;HEALTHCHECK&quot;. &quot;HEALTHCHECK&quot; instruction tells Docker &quot;how to test a container to check if it's still working or not?&quot;. This can detect cases such as a web server that is stuck in an infinite loop and unable to handle new connections, even though the server process is still running so the container is up. When we run a container which has a healthcheck defined in its image, this container has a &quot;health&quot; status in addition to its &quot;lifecycle&quot; status. This allows us to monitor container's health status and take action if something goes wrong. In our case, we instructed that each container created from that image should start a healthchecking process and continue to do that every 30 seconds. If container gets a response from http://localhost/, Docker will mark the container as healthy, otherwise unhealthy.</p> <p>All good so far but there's something strange in this Dockerfile. We don't have any CMD instruction in this file. So, which application will be started when a container been created from that image? Is there anything like secret CMD or something else? Answer is really simple. When you build an image, Docker inherits all the settings from base image. If you specify anything on your Dockerfile, it overwrites the same value that is inherited from base image. But if you left it blank, Image uses the inherited value from base image. In our case, we don't have the CMD instruction, so Docker will inherit this from base image. That's enough for the first Dockerfile. Let's take have a look at mysql's Dockerfile too.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ <span class="token function">cat</span> Dockerfile.mysql
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>FROM mysql:5.7
COPY createtable.sql /docker-entrypoint-initdb.d
</code></pre></div><p>This is really short. We're gonna use mysql:5.7 as our base and copy createtable.sql to /docker-entrypoint-initdb.d folder. That's all. When a mysql container is started for the first time, a new database with the specified name will be created and initialized with the provided configuration variables. In addition to that, mysql container executes files with extensions .sh, .sql and .sql.gz that are found in /docker-entrypoint-initdb.d folder. That's the reason why we copy our sql script to this folder. When a container is been created from that image, it'll execute this script and this script will create our database.  (See https://hub.docker.com/_/mysql for details)</p> <p>It's time to build 2 images.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image build -t your_dockerhub_id/php:v1 <span class="token builtin class-name">.</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">11</span>.26kB
Step <span class="token number">1</span>/7 <span class="token builtin class-name">:</span> FROM php:7.3-apache
Step <span class="token number">2</span>/7 <span class="token builtin class-name">:</span> RUN <span class="token function">apt-get</span> update -y <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">curl</span> mariadb-client-10.3 -y
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> dca6dcd061df
<span class="token punctuation">[</span>…<span class="token punctuation">]</span>
<span class="token punctuation">[</span>…<span class="token punctuation">]</span>
<span class="token punctuation">[</span>…<span class="token punctuation">]</span>
Step <span class="token number">6</span>/7 <span class="token builtin class-name">:</span> HEALTHCHECK --interval<span class="token operator">=</span>30s --timeout<span class="token operator">=</span>3s CMD <span class="token function">curl</span> -f http://localhost/ <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
 ---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> d6dc02b8ca50
Removing intermediate container d6dc02b8ca50
 ---<span class="token operator">&gt;</span> bf3e03646cc0
Step <span class="token number">7</span>/7 <span class="token builtin class-name">:</span> COPY ./php/ /var/www/html/
 ---<span class="token operator">&gt;</span> 53959f571f38
Successfully built 53959f571f38
Successfully tagged ozgurozturknetphp:v1
</code></pre></div><p>Php image is ready. Let's build mysql image now.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker image build -f Dockerfile.mysql -t your_dockerhub_id/mysql:v1 <span class="token builtin class-name">.</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>Sending build context to Docker daemon  <span class="token number">11</span>.26kB
Step <span class="token number">1</span>/2 <span class="token builtin class-name">:</span> FROM mysql:5.7
Status: Downloaded newer image <span class="token keyword">for</span> mysql:5.7
 ---<span class="token operator">&gt;</span> 718a6da099d8
Step <span class="token number">2</span>/2 <span class="token builtin class-name">:</span> COPY createtable.sql /docker-entrypoint-initdb.d
 ---<span class="token operator">&gt;</span> 2dfc8038fc98
Successfully built 2dfc8038fc98
Successfully tagged ozgurozturknetmysql:v1
</code></pre></div><p>Done. Images are ready. It's time to run our fancy crm application but first let's create a new bridge network. Web contaier should access to mysql database container via its name. Therefore, these containers must be able to resolve each others name.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker network create php-mysql-net
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>f3b75a829c3f7a8d5268dbf9dcb884071b3affaed642b3fe6354e78193d054c6
</code></pre></div><p>Images are ready. Bridge network has been created. We're ready to create containers.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -d --name phpapp --network php-mysql-net -p <span class="token number">80</span>:80 --env-file env.list your_dockerhub_id/php:v1
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>c580f355ad836c1021ee5959970bdf53c93de088c701af4110e1dfd8e976a80b
</code></pre></div><p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -d --name mysqldb --network php-mysql-net --env-file envmysql.list your_dockerhub_id/mysql:v1
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>02d51c5ad53c0f1fd0679a5b0f4b60a742a07eecd9eb2f7eebbb8eb800bed73e
</code></pre></div><p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker <span class="token function">ps</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>CONTAINER ID        IMAGE                    COMMAND                  CREATED              STATUS                        PORTS                 NAMES
02d51c5ad53c        ozgurozturknetmysql:v1   <span class="token string">&quot;docker-entrypoint.s…&quot;</span>   <span class="token number">53</span> seconds ago       Up <span class="token number">52</span> seconds                 <span class="token number">3306</span>/tcp, <span class="token number">33060</span>/tcp   mysqldb
c580f355ad83        ozgurozturknetphp:v1     <span class="token string">&quot;docker-php-entrypoi…&quot;</span>   About a minute ago   Up About a minute <span class="token punctuation">(</span>healthy<span class="token punctuation">)</span>   <span class="token number">0.0</span>.0.0:80-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp    phpapp
</code></pre></div><p>Containers are up and running and also phpapp's status is healthy. Let's open a browser and see if php application is also working and can connect to mysql database or not. Visit http://127.0.0.1</p> <img src="/trainingdays/assets/img/php1.1bb4d4c2.png"> <p>Fill the form and click add.</p> <img src="/trainingdays/assets/img/php2.3ce706f8.png"> <p>If you saw this message, everything is fine. Click View and check your records.</p> <img src="/trainingdays/assets/img/php3.bb4f2e39.png"> <p>Congratulations! You have successfully built a 2-tier web app and run that locally.</p> <p>Now we can stop and delete the containers. Please don't delete these images for now. We will use these at Challange 5.
Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container <span class="token function">rm</span> -f mysqldb phpapp
</code></pre></div></details> <hr> <p><strong>6: Docker commit</strong></p><details><summary>Click to expand!</summary><p></p> <p>Dockerfile isn't the only way to create an image. We can convert a container to an image too. It can be useful to commit a container’s file changes or settings into a new image. This allows us to debug a container by running an interactive shell, or to export a working dataset to another server. Generally, it is better to use Dockerfiles to manage your images in a documented and maintainable way, but sometimes this type of commit method is also needed. Let's try this. First let's create a container and create a file in it.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker container run -it --name commit_test busybox <span class="token function">sh</span>
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>/ <span class="token comment"># mkdir /test</span>
/ <span class="token comment"># cd /test</span>
/test <span class="token comment"># touch test.txt</span>
/test <span class="token comment"># echo &quot;hello world&quot; &gt; test.txt</span>
/test <span class="token comment"># exit</span>
</code></pre></div><p>Let's assume that we have an important container. We have connected to it and made lots of changes. Created folders and files, installed something etc. We don't want to loose our efforts and keep this container as an image. So we can move it anywhere. Let's commit this container and convert it to an image.</p> <p>Type:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>$ docker commit commit_test ozgurozturknet/commit:latest
</code></pre></div><p>Output will be something like:</p> <div class="language-shell extra-class"><pre class="language-shell"><code>sha256:8f5d8a8e42bd9419f6a932c0e70b0700f0618096d6c3f4a06753520fac236ed7
</code></pre></div><p>Our image is ready. Now if we want, we can push it to our repository and move it to anywhere we want.
</p></details><p></p> <hr> <h2 id="wrap-up"><a href="#wrap-up" class="header-anchor">#</a> Wrap up</h2> <p><strong>Congratulations</strong> you have completed the Image and Registry challenge and learned how to create Docker images and play with them.</p> <p>*** Reference: https://docs.docker.com</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/azuredevcollege/trainingdays/edit/master/day6/challenges/challenge4.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/trainingdays/assets/js/app.d38bf813.js" defer></script><script src="/trainingdays/assets/js/2.5ff1d4d5.js" defer></script><script src="/trainingdays/assets/js/40.a1779f5a.js" defer></script>
  </body>
</html>
